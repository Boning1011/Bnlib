{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "rawimport", "icon": "SOP/rawimport", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Raw Import"], "extent": [78, 93]}, {"type": "summary", "indent": 0, "text": ["Imports raw binary files as point, detail, or volumes."], "extent": [93, 156]}, {"type": "para", "indent": 0, "text": ["Raw Import loads binary files and creates detail attributes, points, or volumes to represent the data within.   This requires a precise specification of the file layout, including the bit-depth and endianness of the data."], "extent": [156, 379]}, {"type": "para", "indent": 0, "text": ["Reading is done blockwise, and only the specified blocks are read. Some file formats may require multiple Raw Imports; the first to read header information, and later ones with an Ignored block to get to the data that needs to be read."], "extent": [379, 616]}, {"type": "para", "indent": 0, "text": ["For text data the ", {"scheme": "Node", "value": "/nodes/sop/tableimport", "type": "link", "text": ["Table Import SOP"], "fullpath": "/nodes/sop/tableimport.html"}, " can be used."], "extent": [616, 689]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [689, 701], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Raw File"], "extent": [701, 712], "body": [{"type": "para", "indent": 4, "text": ["The file to read."], "extent": [727, 759]}], "container": true, "attrs": {"id": "file"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Reload Geometry"], "extent": [759, 776], "body": [{"type": "para", "indent": 4, "text": ["Trigger re-loading and re-cooking of the file.  Useful if the file has changed on disk."], "extent": [793, 895]}], "container": true, "attrs": {"id": "reload"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["File Layout"], "extent": [895, 913], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Endianness"], "extent": [913, 926], "body": [{"type": "para", "indent": 4, "text": ["The ", {"scheme": "Wp", "value": "http://en.wikipedia.org/wiki/Endianness", "type": "link", "text": ["byte ordering"], "exists": true}, " of the raw data. Unless all the data\n    is single bytes, you need to set this based on how the data was created.\n    There is no way to tell what to set this to, other than knowing which\n    ", {"type": "q", "text": ["endian-ness"]}, " the program that created the data used, however ", {"type": "q", "text": ["Little"]}, "\n    (the default) is common on modern systems."], "extent": [943, 1292]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Little (Intel)"], "extent": [1292, 1312], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "em", "text": ["least significant"]}, " byte in a multi-byte number is first.\n        This matches the normal memory layout of modern architectures (Intel\n        and ARM), so it is commonly used."], "extent": [1312, 1510]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Big (Network)"], "extent": [1510, 1529], "body": [{"type": "para", "indent": 8, "text": ["The ", {"type": "em", "text": ["most significant"]}, " byte in a multi-byte number is first. This is\n        sometimes called ", {"type": "q", "text": ["network ordering"]}, " and is common in, but not limited\n        to, network protocols."], "extent": [1529, 1716]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["While many know the story of Gulliver\u2019s travels, of how the\n    eponymous main character washed ashore of a land of little people,\n    they may not recall why the nations of that island were at war.\n    There was a schism about whether eggs should be cracked from their\n    little side or the big side first."], "extent": [1716, 2030]}, {"type": "para", "indent": 4, "text": ["A similar problem arose in the world of computer science.  When\n    storing a multi-byte value, do you store the big portion or the\n    little portion first?"], "extent": [2030, 2197]}], "container": true, "attrs": {"id": "endian"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Point Count"], "extent": [2197, 2210], "body": [{"type": "para", "indent": 4, "text": ["If point attributes are read from the file, points must be created\n    to hold the attributes.   This controls how the number of points\n    is determined."], "extent": [2235, 2399]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["No Points"], "extent": [2399, 2414], "body": [{"type": "para", "indent": 8, "text": ["No points are to be created. There should not be any\n        point-attribute blocks in this case."], "extent": [2414, 2529]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Specific Points"], "extent": [2529, 2550], "body": [{"type": "para", "indent": 8, "text": ["A specific number of points are created.  All point-based\n        blocks will have this size."], "extent": [2550, 2661]}], "container": true}, {"type": "dt", "indent": 4, "text": ["From Header"], "extent": [2661, 2678], "body": [{"type": "para", "indent": 8, "text": ["If a block creates a detail attribute; that detail\n        attribute\u2019s value can be used to set the number of points.\n        This avoids the need to do a multi-pass if the point count is\n        embedded in the file.   The detail block must precede the\n        first point block."], "extent": [2678, 2976]}], "container": true}, {"type": "dt", "indent": 4, "text": ["From File Size"], "extent": [2976, 2996], "body": [{"type": "para", "indent": 8, "text": ["Most file sources allow determination of the file size.  When\n        this is possible, the number of points can be inferred by\n        computing the left over space after all the other blocks are\n        accounted for.  This requires any header or trailer blocks to\n        be properly defined to ensure the remaining bytes can be\n        distributed among the point attributes."], "extent": [2996, 3398]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "pointcounttype"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number of Points"], "extent": [3398, 3416], "body": [{"type": "para", "indent": 4, "text": ["How many points to create."], "extent": [3437, 3478]}], "container": true, "attrs": {"id": "pointcount"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Point Count Attrib"], "extent": [3478, 3498], "body": [{"type": "para", "indent": 4, "text": ["A detail attribute that should be created by a detail-block whose\n    value will determine the number of points to create."], "extent": [3525, 3662]}], "container": true, "attrs": {"id": "pointcountattrib"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Number of Blocks"], "extent": [3662, 3687], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Block #"], "extent": [3687, 3697], "body": [{"type": "para", "indent": 4, "text": ["The name of the block. This becomes the attribute name for\n    detail or point blocks, and the volume name for volume blocks.\n    For an ignored block it is a useful way to comment why the block\n    exists."], "extent": [3713, 3934]}], "container": true, "attrs": {"id": "name#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Import Target"], "extent": [3934, 3949], "body": [{"type": "para", "indent": 4, "text": ["Where to put the data read from the block."], "extent": [3967, 4019]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Ignored"], "extent": [4019, 4032], "body": [{"type": "para", "indent": 8, "text": ["The data will be ignored."], "extent": [4032, 4075]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Detail Attribute"], "extent": [4075, 4097], "body": [{"type": "para", "indent": 8, "text": ["The data will be stored into a detail attribute."], "extent": [4097, 4163]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Point Attribute"], "extent": [4163, 4184], "body": [{"type": "para", "indent": 8, "text": ["The data will be stored into a point attribute spread across\n        all the points that were generated."], "extent": [4184, 4306]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Volume"], "extent": [4306, 4318], "body": [{"type": "para", "indent": 8, "text": ["The data will be stored into a volume."], "extent": [4318, 4379]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "target#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Tuple Size"], "extent": [4379, 4391], "body": [{"type": "para", "indent": 4, "text": ["The number of entries per data element.  For point attributes, the\n    ", {"type": "q", "text": ["P"]}, " attribute must be at most size 3.  Likewise, float volumes only\n    support 1-4 tuplesizes."], "extent": [4412, 4593]}], "container": true, "attrs": {"id": "tuplesize#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Type"], "extent": [4593, 4599], "body": [{"type": "para", "indent": 4, "text": ["The type of data stored in this block."], "extent": [4615, 4663]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Float"], "extent": [4663, 4674], "body": [{"type": "para", "indent": 8, "text": ["Floating point values."], "extent": [4674, 4714]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Integer"], "extent": [4714, 4727], "body": [{"type": "para", "indent": 8, "text": ["Integral values."], "extent": [4727, 4766]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "type#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Precision"], "extent": [4766, 4777], "body": [{"type": "para", "indent": 4, "text": ["How many bits to store for each value."], "extent": [4798, 4846]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["8-bit"], "extent": [4846, 4857], "body": [{"type": "para", "indent": 8, "text": ["For integers this is an unsigned value from 0..255.  For\n        float, the unsigned value 0..255 will be fit to the floating\n        point values 0..1."], "extent": [4857, 5027]}], "container": true}, {"type": "dt", "indent": 4, "text": ["16-bit"], "extent": [5027, 5039], "body": [{"type": "para", "indent": 8, "text": ["For integers, this is a signed value from -32768..32767.  For\n        float, this is either binary16 or bfloat16."], "extent": [5039, 5170]}], "container": true}, {"type": "dt", "indent": 4, "text": ["32-bit"], "extent": [5170, 5182], "body": [{"type": "para", "indent": 8, "text": ["For integers, this is a signed 32 bit value.  For float, it is\n        a binary32 floating point representation."], "extent": [5182, 5312]}], "container": true}, {"type": "dt", "indent": 4, "text": ["64-bit"], "extent": [5312, 5324], "body": [{"type": "para", "indent": 8, "text": ["For integers, this is a signed 64 bit value.  For float, it is\n        a binary64 floating point representation."], "extent": [5324, 5459]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "precision#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use BFloat16"], "extent": [5459, 5473], "body": [{"type": "para", "indent": 4, "text": ["The usual 16-bit float representation, often called half, is\n    binary16.  This is used by OpenEXR and OpenVDB and internally in\n    Houdini as a way to store floats in less space by reducing both\n    the range and the precision."], "extent": [5491, 5727]}, {"type": "para", "indent": 4, "text": ["BFloat16 is a truncated version of binary32 where the range\n    remains unchanged, but the precision has been reduced to a mere\n    8-bits.  This is commonly used in machine learning."], "extent": [5727, 5920]}], "container": true, "attrs": {"id": "bfloat#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Collate with Previous"], "extent": [5920, 5943], "body": [{"type": "para", "indent": 4, "text": ["When a point block is loaded from disk, it could either be\n    interleaved with other point blocks or form its own contiguous\n    block.   If it is not marked as being collated, it will load its\n    own contiguous block (possibly including any successive blocks\n    that are marked as collated)   If it is marked as collated, all\n    the blocks that are collated together will be read in turn for\n    each point before going to the next point."], "extent": [5962, 6420]}], "container": true, "attrs": {"id": "collate#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Volume Resolution"], "extent": [6420, 6439], "body": [{"type": "para", "indent": 4, "text": ["The resolution of the volume to load.   If an axis is -1, it is\n    treated as dynamic.  The dynamic axes will be determined by taking\n    the remainder of the total file size (if available) and dividing\n    it among the dynamic axes equally.  Thus if more than one axis is\n    dynamic, the volume must be an even square or cube."], "extent": [6457, 6796]}], "container": true, "attrs": {"id": "volres#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Volume Order"], "extent": [6796, 6810], "body": [{"type": "para", "indent": 4, "text": ["Similar to ", {"scheme": "Wp", "value": "http://en.wikipedia.org/wiki/Endianness", "type": "link", "text": ["endian-ness"], "exists": true}, " for binary numbers, there is\n    disagreement about whether volume data should be X-axis first, or\n    Z-axis first. If you are reading volume data, you need to set this\n    based on the convention used by the program that created the data."], "extent": [6830, 7115]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["ZYX"], "extent": [7115, 7124], "body": [{"type": "para", "indent": 8, "text": ["The Z-axis is the outermost loop.  Consecutive elements in\n        the file will be consecutive X-values.\n        This matches Houdini\u2019s internal Volume layout."], "extent": [7124, 7302]}], "container": true}, {"type": "dt", "indent": 4, "text": ["XYZ"], "extent": [7302, 7311], "body": [{"type": "para", "indent": 8, "text": ["The X-axis is the outermost loop.  Consecutive elements in the\n        file will be consecutive Z-values.\n        This matches OpenVDB\u2019s internal volume layout."], "extent": [7311, 7485]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "volorder#"}, "role": "item"}], "container": true, "role": "item_group"}]}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [7485, 7494], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/tableimport", "type": "link", "text": "", "fullpath": "/nodes/sop/tableimport.html"}], "extent": [7494, 7520]}], "container": true}], "text": "Related"}], "title": ["Raw Import"], "summary": ["Imports raw binary files as point, detail, or volumes."]}