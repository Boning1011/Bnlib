{"type": "root", "attrs": {"type": "node", "context": "top", "internal": "attributefromstring", "icon": "TOP/attributefromstring", "since": "17.5", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Attribute from String"], "extent": [0, 26]}, {"type": "summary", "indent": 0, "text": ["Parses attribute values from a string, such as a file name."], "extent": [138, 205]}, {"type": "para", "indent": 0, "text": ["The node lets you choose between using a ", {"scheme": null, "value": "#simple", "type": "link", "text": ["simple pattern replacement language"], "fullpath": "/nodes/top/attributefromstring.html#simple", "fragment": "#simple"}, ", or full-on ", {"scheme": null, "value": "#regex", "type": "link", "text": ["regular expressions"], "fullpath": "/nodes/top/attributefromstring.html#regex", "fragment": "#regex"}, ". The simple patterns are easier to write and make sense to use for structured strings with separators."], "extent": [205, 438]}, {"level": 2, "id": "simple", "container": true, "type": "h", "indent": 0, "text": ["Simple pattern language"], "extent": [438, 477], "body": [{"type": "para", "indent": 0, "text": ["This node supports a fairly simple pattern language, alternating named ", {"type": "q", "text": ["capture"]}, " groups and literal characters. The strings captured by the groups are assigned to attributes. This can be useful for parsing information out of file names, if the name has a regular structure with separator characters."], "extent": [477, 779]}, {"type": "para", "indent": 0, "text": ["For example, given ", {"type": "q", "text": ["source"]}, " file names in the form:"], "extent": [779, 832]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["shot_a.simcache.1.005.bgeo.sc"]}], "extent": [832, 865]}, {"type": "para", "indent": 0, "text": ["You can parse the different parts into attributes using a pattern such as:"], "extent": [865, 941]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["{shot}.{}.{wedgenum}.{frame}.bgeo.sc"]}], "extent": [941, 981]}, {"type": "para", "indent": 0, "text": ["(Empty braces capture a string but aren\u2019t assigned to an attribute.)"], "extent": [981, 1051]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["In the pattern, curly braces (", {"type": "code", "text": ["{", {"type": "var", "text": ["name"]}, "}"]}, ") match up to the next literal character in the pattern."], "extent": [1051, 1153], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["If the braces are empty, the matching string is thrown away."], "extent": [1153, 1221]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The braces contain a name, the matching string is assigned to an attribute with that name. For exmaple, the part of the source string ", {"type": "q", "text": ["captured"]}, " by ", {"type": "code", "text": ["{shot}"]}, " is assigned to the ", {"type": "code", "text": ["shot"]}, " attribute."], "extent": [1221, 1422]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["If ", {"type": "ui", "text": ["Infer attribute type"]}, " is on, the node guesses the attribute type based on the matched string (if it looks like a whole number, it\u2019s an integer; if it looks like a number with a decimal point, it\u2019s a float; otherwise it\u2019s a string). You can explicitly specify the type using ", {"type": "code", "text": ["{", {"type": "var", "text": ["name"]}, ":", {"type": "var", "text": ["type"]}, "}"]}, ". For example, ", {"type": "code", "text": ["{shot:string}"]}, ", ", {"type": "code", "text": ["{frame:int}"]}, ", ", {"type": "code", "text": ["{time:float}"]}, "."], "extent": [1422, 1793]}], "container": true}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If you have capture braces at the end of the pattern, they match to the end of the source string."], "extent": [1793, 1894]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Outside braces, characters in the pattern must match characters in the source string exactly."], "extent": [1894, 1991]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Braces are not ", {"type": "q", "text": ["greedy"]}, "\u2026 they only match up to the next literal character, even if going further would give a better match."], "extent": [1991, 2120], "body": [{"type": "para", "indent": 4, "text": ["For example, in ", {"type": "code", "text": ["day.01.csv"]}, ", with the pattern ", {"type": "code", "text": ["{name}.csv"]}, " you might expect ", {"type": "code", "text": ["{name}"]}, " to capture ", {"type": "code", "text": ["day.01"]}, ", but in fact it will only capture ", {"type": "code", "text": ["day"]}, " (since it captures up to the next literal character, a period). The pattern will then fail because it expects the characters after the period to be ", {"type": "code", "text": ["csv"]}, ", not ", {"type": "code", "text": ["01"]}, "."], "extent": [2120, 2436]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "strong", "text": ["whole"]}, " pattern must match the source string (not just a prefix)."], "extent": [2436, 2509]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If the whole pattern doesn\u2019t match, none of the attributes in the pattern will be set."], "extent": [2509, 2600]}], "container": true}]}, {"level": 2, "id": "regex", "container": true, "type": "h", "indent": 0, "text": ["Regular expression"], "extent": [2600, 2633], "body": [{"type": "para", "indent": 0, "text": ["For maximum power/flexibility, you can use a regular expression instead. This node uses ", {"scheme": null, "value": "https://docs.python.org/3/library/re.html", "type": "link", "text": ["Python\u2019s regular expression syntax"], "exists": true}, "."], "extent": [2633, 2803]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Using a regular expression implies ", {"type": "ui", "text": ["Infer attribute type"]}, "."], "extent": [2803, 2868]}], "container": true}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [2868, 2880], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Generate When"], "extent": [16, 31], "body": [{"type": "para", "indent": 4, "text": ["Determines when this node will generate work items. You should generally leave this set to ", {"type": "q", "text": ["Automatic"]}, " unless you know the node requires a specific generation mode, or that the work items need to be generated dynamically."], "extent": [64, 291]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["All Upstream Items are Generated"], "extent": [291, 329], "body": [{"type": "para", "indent": 11, "text": ["This node will generate work items once all of the input nodes have generated their work items."], "extent": [329, 437]}], "container": true}, {"type": "dt", "indent": 4, "text": ["All Upstream Items are Cooked"], "extent": [437, 472], "body": [{"type": "para", "indent": 11, "text": ["This node will generate work items once all of the input nodes have cooked their work items."], "extent": [472, 577]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Each Upstream Item is Cooked"], "extent": [577, 611], "body": [{"type": "para", "indent": 11, "text": ["This node will generate work items each time a work item in an input node is cooked."], "extent": [611, 708]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Automatic"], "extent": [708, 723], "body": [{"type": "para", "indent": 11, "text": ["The generation mode is selected based on the generation mode of the input nodes. If any of the input nodes are generating work items when their inputs cook, this node will be set to ", {"type": "ui", "text": ["Each Upstream Item is Cooked"]}, ". Otherwise, it will be set to ", {"type": "ui", "text": ["All Upstream Items are Generated"]}, "."], "extent": [723, 1018]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "pdg_workitemgeneration"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Source String"], "extent": [2932, 2947], "body": [{"type": "para", "indent": 4, "text": ["The string containing data you want to parse. Usually this is an expression to get the string from an attribute. Since this is a string parameter, you need to enclose the expression in back-ticks. For example: ", {"tag": "code", "attrs": {}, "type": "xml", "text": ["`@name`"]}], "extent": [2970, 3214]}], "container": true, "attrs": {"id": "sourcestring"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Operation"], "extent": [3214, 3225], "body": [{"type": "para", "indent": 4, "text": ["Determines which operation to perform on the source string. ", {"type": "ui", "text": ["Match by String"]}, " will extract components from the ", {"type": "ui", "text": ["Source String"]}, " using a pattern and store them as attributes. ", {"type": "ui", "text": ["Split by Delimiter"]}, " will split the source string based on a secondary string and store the resulting substrings as attributes."], "extent": [3245, 3557]}], "container": true, "attrs": {"id": "operation"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Match by Pattern"], "extent": [3557, 3582], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Pattern Type"], "extent": [3582, 3597], "body": [{"type": "para", "indent": 4, "text": ["Determines if the ", {"type": "ui", "text": ["Pattern"]}, " field is using the ", {"scheme": null, "value": "#simple", "type": "link", "text": ["simple brace syntax"], "fullpath": "/nodes/top/attributefromstring.html#simple", "fragment": "#simple"}, " or a ", {"scheme": null, "value": "#regex", "type": "link", "text": ["regular expression"], "fullpath": "/nodes/top/attributefromstring.html#regex", "fragment": "#regex"}, ". When using a regular expression, captured groups are assigned to attributes by number, for example, ", {"type": "code", "text": ["group0"]}, ", ", {"type": "code", "text": ["group1"]}, ", and so on. If the capture groups are named, e.g. using the syntax ", {"type": "code", "text": ["(?P<name>)"]}, ", then the attribute name is set to the capture group name."], "extent": [3616, 3992]}], "container": true, "attrs": {"id": "useregex"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pattern"], "extent": [3992, 4001], "body": [{"type": "para", "indent": 4, "text": ["The pattern to use to extract attributes from the ", {"type": "ui", "text": ["Source string"]}, ". The language is controlled by the ", {"type": "ui", "text": ["Use custom regex"]}, " checkbox. When the checkbox is off, this parameter uses a ", {"scheme": null, "value": "#simple", "type": "link", "text": ["simple pattern substitution language"], "fullpath": "/nodes/top/attributefromstring.html#simple", "fragment": "#simple"}, " (see above). When the checkbox is on, this parameter is a ", {"scheme": null, "value": "#regex", "type": "link", "text": ["regular expression"], "fullpath": "/nodes/top/attributefromstring.html#regex", "fragment": "#regex"}, "."], "extent": [4023, 4344]}], "container": true, "attrs": {"id": "matchstring"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Infer Attribute Type"], "extent": [4344, 4366], "body": [{"type": "para", "indent": 4, "text": ["When this is on, if you don\u2019t explicitly state the type of a capture pattern (for example, ", {"type": "code", "text": ["{shotnum:int}"]}, "), the node will try to guess the type based on the matched string content (if it looks like a whole number, it\u2019s an integer; if it looks like a number with a decimal point, it\u2019s a float; otherwise it\u2019s a string). "], "extent": [4386, 4712]}], "container": true, "attrs": {"id": "infertype"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Items With No Matches"], "extent": [4712, 4742], "body": [{"type": "para", "indent": 4, "text": ["By default, the node only creates new work items from incoming items where the pattern matched. When this is on, work items are passed through even if they didn\u2019t match."], "extent": [4766, 4941]}], "container": true, "attrs": {"id": "createnomatch"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Split by Delimiter"], "extent": [4941, 4968], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Delimiter Type"], "extent": [4968, 4985], "body": [{"type": "para", "indent": 4, "text": ["Specified what type of delimiter to use for splitting the ", {"type": "ui", "text": ["Source String"]}, ". Using ", {"type": "ui", "text": ["String"]}, " will split the source string based on the exact contents of the ", {"type": "ui", "text": ["Delimiter"]}, " field. ", {"type": "ui", "text": ["Character Set"]}, " attempts to split based on each of the delimiter characters individually. ", {"type": "ui", "text": ["Regular Expression"]}, " will interpret the ", {"type": "ui", "text": ["Delimiter"]}, " as a custom regex."], "extent": [5009, 5360]}], "container": true, "attrs": {"id": "delimitertype"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Delimiter"], "extent": [5360, 5371], "body": [{"type": "para", "indent": 4, "text": ["The delimiter to use when splitting the source string."], "extent": [5391, 5451]}], "container": true, "attrs": {"id": "delimiter"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Store Result As"], "extent": [5451, 5468], "body": [{"type": "para", "indent": 4, "text": ["How the split string is stored. The components can either be stored as a string array attribute on a single work item, or split into one work item per component."], "extent": [5486, 5653]}], "container": true, "attrs": {"id": "storage"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Split Attribute"], "extent": [5653, 5670], "body": [{"type": "para", "indent": 4, "text": ["The name of the attribute created on each work item that contains the split compenents from the ", {"type": "ui", "text": ["Source String"]}, ". If this parameter is disabled then no attribute is created."], "extent": [5695, 5875]}], "container": true, "attrs": {"id": "splitattribute"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Count Attribute"], "extent": [5875, 5892], "body": [{"type": "para", "indent": 4, "text": ["The name of the attribute created on each work item that contains the total number of delimiter-separated components in the ", {"type": "ui", "text": ["Source String"]}, ". If this parameter is disabled then no attribute is created."], "extent": [5921, 6129]}], "container": true, "attrs": {"id": "countattribute"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Index Attribute"], "extent": [6129, 6146], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Store Result As"]}, " is set to ", {"type": "ui", "text": ["Separate Work Items"]}, ", this parameter determines the name of the attribute created on the work items to identify their position in the split component list. If this parameter is disabled the no attribute is created."], "extent": [6171, 6429]}], "container": true, "attrs": {"id": "indexattribute"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Trim Whitespace"], "extent": [6429, 6446], "body": [{"type": "para", "indent": 4, "text": ["When this toggle is enabled, leading and trailing whitespace is removed from the components after splitting the string."], "extent": [6466, 6591]}], "container": true, "attrs": {"id": "trimspace"}, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [6591, 6600], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/top/attributecreate", "type": "link", "text": "", "fullpath": "/nodes/top/attributecreate.html"}], "extent": [6600, 6630]}], "container": true}], "text": "Related"}], "title": ["Attribute from String"], "summary": ["Parses attribute values from a string, such as a file name."], "included": ["/nodes/top/processor_common"]}