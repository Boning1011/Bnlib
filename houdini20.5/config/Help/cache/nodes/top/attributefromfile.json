{"type": "root", "attrs": {"type": "node", "context": "top", "internal": "attributefromfile", "icon": "TOP/attributefromfile", "since": "20.0", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Attribute from File"], "extent": [0, 24]}, {"type": "summary", "indent": 0, "text": ["Parses attribute values from a file into work items."], "extent": [132, 192]}, {"type": "para", "indent": 0, "text": ["The node lets you choose a (regex) delimiter between sets of attributes listed in a file; for files with work item data separated line-by-line, this delimiter would be ", {"type": "code", "text": ["\\n"]}, ". The text for each attribute set is futher parsed into a new work item by using a ", {"scheme": null, "value": "#simple", "type": "link", "text": ["simple pattern replacement language"], "fullpath": "/nodes/top/attributefromfile.html#simple", "fragment": "#simple"}, ", or full-on ", {"scheme": null, "value": "#regex", "type": "link", "text": ["regular expressions"], "fullpath": "/nodes/top/attributefromfile.html#regex", "fragment": "#regex"}, ". The simple patterns are easier to write and make sense to use for structured strings with separators."], "extent": [192, 639]}, {"level": 2, "id": "simple", "container": true, "type": "h", "indent": 0, "text": ["Simple pattern language"], "extent": [639, 678], "body": [{"type": "para", "indent": 0, "text": ["This node supports a fairly simple pattern language (similar to the Attribute from String node), alternating named ", {"type": "q", "text": ["capture"]}, " groups and literal characters. The strings captured by the groups are assigned to attributes. This can be useful for parsing information formatted in a regular structure with separator characters."], "extent": [678, 1002]}, {"type": "para", "indent": 0, "text": ["For example, given a line in a file describing a set of attributes in the form:"], "extent": [1002, 1083]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["\"cat\",\"cat0.png\",1"]}], "extent": [1083, 1105]}, {"type": "para", "indent": 0, "text": ["You can parse the different parts into attributes using a pattern such as:"], "extent": [1105, 1181]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["\"{name}\",\"{filename}.{}\",{size:int}"]}], "extent": [1181, 1220]}, {"type": "para", "indent": 0, "text": ["(Empty braces capture a string but aren\u2019t assigned to an attribute.)"], "extent": [1220, 1290]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["In the pattern, curly braces (", {"type": "code", "text": ["{", {"type": "var", "text": ["name"]}, "}"]}, ") match up to the next literal character in the pattern."], "extent": [1290, 1392], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["If the braces are empty, the matching string is thrown away."], "extent": [1392, 1460]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The braces contain a name, the matching string is assigned to an attribute with that name. For exmaple, the part of the source string ", {"type": "q", "text": ["captured"]}, " by ", {"type": "code", "text": ["{name}"]}, " is assigned to the ", {"type": "code", "text": ["shot"]}, " attribute."], "extent": [1460, 1661]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["If ", {"type": "ui", "text": ["Infer attribute type"]}, " is on, the node guesses the attribute type based on the matched string (if it looks like a whole number, it\u2019s an integer; if it looks like a number with a decimal point, it\u2019s a float; otherwise it\u2019s a string). You can explicitly specify the type using ", {"type": "code", "text": ["{", {"type": "var", "text": ["name"]}, ":", {"type": "var", "text": ["type"]}, "}"]}, ". For example, ", {"type": "code", "text": ["{shot:string}"]}, ", ", {"type": "code", "text": ["{frame:int}"]}, ", ", {"type": "code", "text": ["{time:float}"]}, "."], "extent": [1661, 2032]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Braces with no type or a string type only match text containing alphanumeric characters and underscores. Formally, they match text using the regex ", {"type": "code", "text": ["\\w+"]}, "."], "extent": [2032, 2193]}], "container": true}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If you have capture braces at the end of the pattern, they match to the end of the source string."], "extent": [2193, 2294]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Outside braces, characters in the pattern must match characters in the source string exactly."], "extent": [2294, 2391]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Braces are not ", {"type": "q", "text": ["greedy"]}, "\u2026 they only match up to the next literal character, even if going further would give a better match."], "extent": [2391, 2520], "body": [{"type": "para", "indent": 4, "text": ["For example, in ", {"type": "code", "text": ["day.01.csv"]}, ", with the pattern ", {"type": "code", "text": ["{name}.csv"]}, " you might expect ", {"type": "code", "text": ["{name}"]}, " to capture ", {"type": "code", "text": ["day.01"]}, ", but in fact it will only capture ", {"type": "code", "text": ["day"]}, " (since it captures up to the next literal character, a period). The pattern will then fail because it expects the characters after the period to be ", {"type": "code", "text": ["csv"]}, ", not ", {"type": "code", "text": ["01"]}, "."], "extent": [2520, 2836]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "strong", "text": ["whole"]}, " pattern must match the source string (not just a prefix)."], "extent": [2836, 2909]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If the whole pattern doesn\u2019t match, none of the attributes in the pattern will be set."], "extent": [2909, 3000]}], "container": true}]}, {"level": 2, "id": "regex", "container": true, "type": "h", "indent": 0, "text": ["Regular expression"], "extent": [3000, 3033], "body": [{"type": "para", "indent": 0, "text": ["For maximum power/flexibility, you can use a regular expression instead. This node uses ", {"scheme": null, "value": "https://docs.python.org/3/library/re.html", "type": "link", "text": ["Python\u2019s regular expression syntax"], "exists": true}, "."], "extent": [3033, 3203]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Using a regular expression implies ", {"type": "ui", "text": ["Infer attribute type"]}, "."], "extent": [3203, 3268]}], "container": true}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [3268, 3280], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Generate When"], "extent": [16, 31], "body": [{"type": "para", "indent": 4, "text": ["Determines when this node will generate work items. You should generally leave this set to ", {"type": "q", "text": ["Automatic"]}, " unless you know the node requires a specific generation mode, or that the work items need to be generated dynamically."], "extent": [64, 291]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["All Upstream Items are Generated"], "extent": [291, 329], "body": [{"type": "para", "indent": 11, "text": ["This node will generate work items once all of the input nodes have generated their work items."], "extent": [329, 437]}], "container": true}, {"type": "dt", "indent": 4, "text": ["All Upstream Items are Cooked"], "extent": [437, 472], "body": [{"type": "para", "indent": 11, "text": ["This node will generate work items once all of the input nodes have cooked their work items."], "extent": [472, 577]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Each Upstream Item is Cooked"], "extent": [577, 611], "body": [{"type": "para", "indent": 11, "text": ["This node will generate work items each time a work item in an input node is cooked."], "extent": [611, 708]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Automatic"], "extent": [708, 723], "body": [{"type": "para", "indent": 11, "text": ["The generation mode is selected based on the generation mode of the input nodes. If any of the input nodes are generating work items when their inputs cook, this node will be set to ", {"type": "ui", "text": ["Each Upstream Item is Cooked"]}, ". Otherwise, it will be set to ", {"type": "ui", "text": ["All Upstream Items are Generated"]}, "."], "extent": [723, 1018]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "pdg_workitemgeneration"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["File Path"], "extent": [3332, 3343], "body": [{"type": "para", "indent": 4, "text": ["Path of the file to parse."], "extent": [3362, 3394]}], "container": true, "attrs": {"id": "filepath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Work Item Delimiter (regex)"], "extent": [3394, 3423], "body": [{"type": "para", "indent": 4, "text": ["Separator regular expression between text containing attribute values for a work item."], "extent": [3447, 3539]}], "container": true, "attrs": {"id": "workitemdelim"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pattern Type"], "extent": [3539, 3553], "body": [{"type": "para", "indent": 4, "text": ["Determines if the ", {"type": "ui", "text": ["Pattern"]}, " field is using the ", {"scheme": null, "value": "#simple", "type": "link", "text": ["simple brace syntax"], "fullpath": "/nodes/top/attributefromfile.html#simple", "fragment": "#simple"}, " or a ", {"scheme": null, "value": "#regex", "type": "link", "text": ["regular expression"], "fullpath": "/nodes/top/attributefromfile.html#regex", "fragment": "#regex"}, ". When using a regular expression, captured groups are assigned to attributes by number, for example, ", {"type": "code", "text": ["group0"]}, ", ", {"type": "code", "text": ["group1"]}, ", and so on. If the capture groups are named, e.g. using the syntax ", {"type": "code", "text": ["(?P<name>)"]}, ", then the attribute name is set to the capture group name."], "extent": [3572, 3948]}], "container": true, "attrs": {"id": "useregex"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pattern"], "extent": [3948, 3957], "body": [{"type": "para", "indent": 4, "text": ["The pattern to use to extract attributes from each string in a delimiter-separated file. The language is controlled by the ", {"type": "ui", "text": ["Use custom regex"]}, " checkbox. When the checkbox is off, this parameter uses a ", {"scheme": null, "value": "#simple", "type": "link", "text": ["simple pattern substitution language"], "fullpath": "/nodes/top/attributefromfile.html#simple", "fragment": "#simple"}, " (see above). When the checkbox is on, this parameter is a ", {"scheme": null, "value": "#regex", "type": "link", "text": ["regular expression"], "fullpath": "/nodes/top/attributefromfile.html#regex", "fragment": "#regex"}, "."], "extent": [3985, 4326]}], "container": true, "attrs": {"id": "attribmatchstring"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Infer Attribute Type"], "extent": [4326, 4348], "body": [{"type": "para", "indent": 4, "text": ["When this is on, if you don\u2019t explicitly state the type of a capture pattern (for example, ", {"type": "code", "text": ["{shotnum:int}"]}, "), the node will try to guess the type based on the matched string content (if it looks like a whole number, it\u2019s an integer; if it looks like a number with a decimal point, it\u2019s a float; otherwise it\u2019s a string). "], "extent": [4368, 4694]}], "container": true, "attrs": {"id": "infertype"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Items With No Matches"], "extent": [4694, 4724], "body": [{"type": "para", "indent": 4, "text": ["By default, the node only creates new work items from a string where the pattern matched. When this is on, work items are created even if they didn\u2019t match."], "extent": [4748, 4910]}], "container": true, "attrs": {"id": "createnomatch"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Parsing Issues"], "extent": [4910, 4926], "body": [{"type": "para", "indent": 4, "text": ["How to report parsing issues such as a failed match."], "extent": [4948, 5006]}], "container": true, "attrs": {"id": "parseissues"}, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5006, 5015], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/top/attributecreate", "type": "link", "text": "", "fullpath": "/nodes/top/attributecreate.html"}], "extent": [5015, 5045]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/top/attributefromstring", "type": "link", "text": "", "fullpath": "/nodes/top/attributefromstring.html"}], "extent": [5045, 5078]}], "container": true}], "text": "Related"}], "title": ["Attribute from File"], "summary": ["Parses attribute values from a file into work items."], "included": ["/nodes/top/processor_common"]}